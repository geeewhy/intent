//src/core/system/command-access.ts
import {
    registerCondition,
    registerCommandConditionsFromModel,
} from '../policy-registry';
import { AccessContext } from '../contracts';
import { SystemRole } from './contracts';

// manual semantic conditions
export enum SystemAccessCustomConditions {
    CAN_TRIGGER_FAILURE = 'system.canTriggerFailure',
    CAN_EMIT_EVENTS = 'system.canEmitEvents',
    CAN_EXECUTE_TEST = 'system.canExecuteTest',
}

registerCondition(SystemAccessCustomConditions.CAN_TRIGGER_FAILURE, ({ role }: AccessContext) =>
    role === 'system'
);

registerCondition(SystemAccessCustomConditions.CAN_EMIT_EVENTS, ({ role }: AccessContext) =>
    ['tester', 'developer', 'system'].includes(role)
);

registerCondition(SystemAccessCustomConditions.CAN_EXECUTE_TEST, ({ role }: AccessContext) =>
    ['tester', 'developer', 'system'].includes(role)
);

// auto generated scope-based conditions
export const systemCommandAccessModel: Record<SystemRole, string[]> = {
    tester: ['logMessage', 'emitMultipleEvents', 'executeTest'],
    system: ['simulateFailure', 'executeRetryableTest'],
    developer: ['logMessage', 'emitMultipleEvents', 'executeTest', 'executeRetryableTest'],
};

// Registers conditions like `system.canExecute.executeTest`
export const autoRegisteredCommandAccessConditions =
    registerCommandConditionsFromModel('system', systemCommandAccessModel);

// Infer valid literal condition strings like: 'system.canExecute.executeTest'
type ExtractedCommandConditions<T extends Record<string, string[]>> =
    T[keyof T][number] extends infer Cmd
        ? `system.canExecute.${Extract<Cmd, string>}`
        : never;

export type ExtractedSystemCommandCondition =
    ExtractedCommandConditions<typeof systemCommandAccessModel>;

// Union of manual and auto-generated condition types
export type SystemCommandAccessCondition =
    | SystemAccessCustomConditions
    | ExtractedSystemCommandCondition;

// autogenerated union of scope-based conditions, its runtime type but useful for type safety if when prebuilds are a thing

const allCommands = Array.from(
    new Set(Object.values(systemCommandAccessModel).flat())
) as readonly string[];

export const GeneratedSystemCommandConditions = Object.fromEntries(
    allCommands.map((cmd) => [cmd.toUpperCase(), `system.canExecute.${cmd}`])
) as {
    [K in Uppercase<typeof allCommands[number]>]: `system.canExecute.${typeof allCommands[number]}`;
};
