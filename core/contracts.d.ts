import { BaseAggregate } from "./base/aggregate";
export type UUID = string;
/**
 * Common Metadata across Commands and Events
 */
export interface Metadata {
    userId?: UUID;
    role?: string;
    timestamp: Date;
    correlationId?: UUID;
    causationId?: UUID;
    requestId?: string;
    source?: string;
    tags?: Record<string, string | number>;
    schemaVersion?: number;
}
/**
 * Base Command interface with lifecycle hints
 */
export interface Command<T = any> {
    id: UUID;
    tenant_id: UUID;
    type: string;
    payload: T;
    status?: 'pending' | 'consumed' | 'processed' | 'failed';
    metadata?: Metadata;
}
/**
 * Base Event interface with versioning and full trace metadata
 */
export interface Event<T = any> {
    id: UUID;
    tenant_id: UUID;
    type: string;
    payload: T;
    aggregateId: UUID;
    aggregateType: string;
    version: number;
    metadata?: Metadata;
}
/**
 * Process plan emitted by sagas or workflows
 */
export interface ProcessPlan {
    commands: Command[];
    delays?: {
        cmd: Command;
        ms: number;
    }[];
    traceContext?: Record<string, any>;
}
/**
 * Contract for defining saga orchestration logic
 */
export interface SagaDefinition {
    idFor: (input: Command | Event) => string | undefined;
    plan: (input: Command | Event, ctx: SagaContext) => Promise<ProcessPlan>;
    workflow?: string;
}
/**
 * Context passed to sagas for deterministic orchestration with optional utilities
 */
export interface SagaContext {
    readonly correlationId?: string;
    nextId(): Promise<UUID>;
    loadAggregate?<T>(aggregateType: string, aggregateId: UUID): Promise<T>;
    loadEvents?(aggregateType: string, aggregateId: UUID): Promise<Event[]>;
    getHint?<T = any>(key: string): T | undefined;
    evaluateCondition?(name: string, args?: any): Promise<boolean>;
    emitInternalSignal?(name: string, data: Record<string, any>): void;
}
/**
 * observability related signals
 */
export declare enum InternalSignalType {
    OBS_TRACE = "obs.trace",
    OBS_WARN = "obs.warn",
    OBS_ERROR = "obs.error",
    OBS_METRIC = "obs.metric"
}
export type InternalSignalPayload = {
    type: 'obs.trace';
    span: string;
    data?: any;
} | {
    type: 'obs.warn';
    message: string;
    tags?: Record<string, any>;
} | {
    type: 'obs.error';
    message: string;
    error?: any;
    tags?: Record<string, any>;
} | {
    type: 'obs.metric';
    name: string;
    value: number;
    tags?: Record<string, any>;
};
/**
 * Projection interfaces
 */
/**
 * Event handler for projections
 */
export interface EventHandler<E extends Event = Event> {
    supportsEvent(event: Event): event is E;
    on(event: E): Promise<void>;
}
/**
 * Command handler interface
 * Each domain service implements this interface to handle specific command types
 */
export interface CommandHandler<C extends Command = Command> {
    /**
     * Check if this handler supports the given command
     * @param cmd The command to check
     * @returns True if this handler supports the command, false otherwise
     */
    supportsCommand(cmd: Command): boolean;
    /**
     * Handle the command with an aggregate
     * @param cmd The command to handle
     * @param aggregate The aggregate to use for handling the command
     * @returns The events generated by handling the command
     */
    handleWithAggregate(cmd: C, aggregate: BaseAggregate<any>): Promise<Event[]>;
}
/**
 * Port for updating read models
 */
export interface ReadModelUpdaterPort<T> {
    upsert(tenantId: string, id: string, data: T): Promise<void>;
    remove(tenantId: string, id: string): Promise<void>;
}
/**
 * Tenant context for multi-tenancy
 */
export interface TenantContext {
    tenantIds: string[];
}
/**
 * Access control context for evaluating policies
 */
export interface AccessContext {
    role: string;
    userId?: string;
    scopes?: string[];
}
/**
 * Access request context for evaluating policies
 */
export interface AccessRequestContext {
    tenantId: string;
    access: AccessContext;
}
/**
 * Trace context for observability
 */
export interface TraceContext {
    emitInternalSignal?(signalName: string, payload?: any): void;
}
